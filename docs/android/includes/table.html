<table width="100%" border="1px">
<tr>
    <td><b>Eigenschaft</b></td>
    <td><b>Beschreibung</b></td>
    <td><b>Optionen</b></td>
</tr>
<tr>
    <td><code>abi.type</code></td>
    <td><strong>ABI-Typ:</strong> Gibt den ABI-Typ (Application Binary Interface) des emulierten Geräts an. Die Option <code>x86</code> gilt für den Anweisungssatz, der üblicherweise als „x86“ oder „IA-32“ bezeichnet wird. Die Option <code>x86_64</code> gilt für die 64-Bit-Anweisungen „x86“. Die Option <code>armeabi-v7a</code> gilt für den ARM-Anweisungssatz mit den ARM-Erweiterungen „v7-a“. Die Option <code>arm64-v8a</code> gilt für den ARM-Anweisungssatz, der AArch64 unterstützt.  </td>
    <td> x86, x86_64, armeabi-v7a, arm64-v8a </td>
</tr>
<tr>
    <td><code>disk.cachePartition</code></td>
    <td><strong>Cachepartition:</strong> Bestimmt, ob das emulierte Gerät eine <strong>/cache</strong>-Partition auf dem Gerät verwendet. Die <strong>/cache</strong>-Partition (anfänglich leer) stellt den Speicherort dar, an dem Android häufig verwendete Daten und App-Komponenten speichert. Wenn der Wert auf <code>no</code> festgelegt wird, verwendet der Emulator keine <strong>/cache</strong>-Partition, und die anderen Einstellungen von <code>disk.cache</code> werden ignoriert.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>disk.cachePartition.path</code></td>
    <td><strong>Pfad der Cachepartition:</strong> Gibt eine Imagedatei für eine Cachepartition auf Ihrem Entwicklungscomputer an. Der Emulator verwendet diese Datei für die <strong>/cache</strong>-Partition. Geben Sie einen absoluten Pfad oder einen Pfad an, der relativ zum <strong>Datenverzeichnis</strong> des Emulators ist. Wenn dieser nicht festgelegt wird, erstellt der Emulator eine leere temporäre Datei namens <strong>cache.img</strong> auf Ihrem Entwicklungscomputer. Wenn die Datei noch nicht vorhanden ist, wird sie als leere Datei erstellt. Diese Option wird ignoriert, wenn <code>disk.cachePartition</code> auf <code>no</code> festgelegt wird. </td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.cachePartition.size</code></td>
    <td><strong>Größe der Cachepartition:</strong> Die Größe der Cachepartitionsdatei (in Megabyte). Normalerweise müssen Sie diese Option nur dann festlegen, wenn die App sehr große Dateien herunterlädt, die die Standardgröße des Caches von 66 Megabyte übersteigen. Diese Option wird ignoriert, wenn <code>disk.cachePartition</code> auf <code>no</code> festgelegt wird.</td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.dataPartition.initPath</code></td>
    <td><strong>Ursprünglicher Pfad zur Datenpartition:</strong> Gibt die ursprünglichen Inhalte der Datenpartition an. Nach dem Zurücksetzen der Benutzerdaten kopiert der Emulator die Inhalte der angegebenen Datei in die Benutzerdaten (standardmäßig <strong>userdata-qemu.img</strong>), statt <strong>userdata.img</strong> als ursprüngliche Version zu verwenden. </td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.dataPartition.path</code></td>
    <td><strong>Pfad zur Datenpartition:</strong> Gibt die Partitionsdatei für Benutzerdaten an. Geben Sie einen Dateinamen und einen Pfad auf Ihrem Entwicklungscomputer ein, um eine permanente Datei für Benutzerdaten zu konfigurieren. Wenn die Datei nicht vorhanden ist, erstellt der Emulator ein Image der Standarddatei (<strong>userdata.img</strong>), speichert diese unter dem Dateinamen, der von <code>disk.dataPartition.path</code> angegeben wird, und behält die Benutzerdaten bei, wenn der Emulator heruntergefahren wird. Wenn Sie keinen Pfad angeben, lautet die Standarddatei <strong>userdata-qemu.img</strong>. Der spezielle Wert <code>&lt;temp></code> bewirkt, dass der Emulator eine temporäre Datei erstellt und verwendet. Wenn <code>disk.dataPartition.initPath</code> festgelegt ist, werden die Inhalte zur Startzeit in die Datei <code>disk.dataPartition.path</code> kopiert. Beachten Sie, dass diese Option nicht leer bleiben darf.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.dataPartition.size</code></td>
    <td><strong>Größe der Datenpartition:</strong> Gibt die Größe der Partition für Benutzerdaten in Megabyte an.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.ramdisk.path</code></td>
    <td><strong>RAMDISK-Pfad:</strong> Pfad zum Image der Startpartition (RAMDISK). Das RAMDISK-Image ist eine Teilmenge des Systemimages, das vom Kernel geladen wird, bevor das Systemimage eingebunden wird. Das RAMDISK-Image enthält üblicherweise die Binärdateien für die Startzeit und Initialisierungsskripts. Wenn diese Option nicht angegeben wird, wird standardmäßig <strong>ramdisk.img</strong> im Systemverzeichnis des Emulators verwendet.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.snapStorage.path</code></td>
    <td><strong>Speicherpfad für Momentaufnahmen:</strong> Der Pfad zur <i>Speicherdatei für Momentaufnahmen</i>, in dem alle Momentaufnahmen gespeichert werden. Alle Momentaufnahmen, die während der Ausführung aufgenommen werden, werden in dieser Datei gespeichert. Nur Momentaufnahmen, die in dieser Datei gespeichert werden, können während der Ausführung des Emulators wiederhergestellt werden. Wenn diese Option nicht angegeben wird, wird standardmäßig <strong>snapshots.img</strong> im Datenverzeichnis des Emulators verwendet.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.systemPartition.initPath</code></td>
    <td><strong>Ursprünglicher Pfad der Systempartition:</strong> Der Pfad zur schreibgeschützten Kopie der Systemimagedatei bzw. die Partition, die die Systembibliotheken und die entsprechenden Daten für die API-Ebene und sämtliche Varianten enthält. Wenn dieser Pfad nicht angegeben wird, wird standardmäßig <strong>system.img</strong> im Systemverzeichnis des Emulators verwendet.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.systemPartition.path</code></td>
    <td><strong>Pfad der Systempartition:</strong> Der Pfad zum Image der Systempartition mit Lese-/Schreibzugriff. Wenn dieser Pfad nicht festgelegt wird, wird aus den Inhalten der durch <code>disk.systemPartition.initPath</code> angegebenen Datei eine temporäre Datei erstellt und initialisiert. </td>
    <td>  </td>
</tr>
<tr>
    <td><code>disk.systemPartition.size</code></td>
    <td><strong>Größe der Systempartition:</strong> Die optimale Größe der Systempartition (in Megabyte). Diese Größenangabe wird ignoriert, wenn die tatsächliche Größe des Images der Systempartition diese Einstellung übersteigt. Andernfalls wird die maximale Größe angegeben, die die Systempartitionsdatei erreichen kann.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.accelerometer</code></td>
    <td><strong>Beschleunigungsmesser:</strong> Bestimmt, ob das emulierte Gerät einen Sensor für Beschleunigungsmessung enthält. Der Beschleunigungsmesser unterstützt das Gerät bei der Orientierung (z.B. für die automatische Drehung). Der Beschleunigungsmesser meldet die Beschleunigung des Geräts an drei Sensorachsen.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.audioInput</code></td>
    <td><strong>Unterstützung der Audioaufzeichnung:</strong> Bestimmt, ob das emulierte Gerät Audio aufzeichnen kann.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.audioOutput</code></td>
    <td><strong>Unterstützung der Audiowiedergabe:</strong> Bestimmt, ob das emulierte Gerät Audio wiedergeben kann.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.battery</code></td>
    <td><strong>Akkuunterstützung:</strong> Bestimmt, ob das emulierte Gerät den Akkubetrieb unterstützt.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.camera</code></td>
    <td><strong>Kameraunterstützung:</strong> Bestimmt, ob das emulierte Gerät über eine Kamera verfügt.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.camera.back</code></td>
    <td><strong>Hintere Kamera:</strong> Konfiguriert die hintere Kamera (der Fokus ist vom Benutzer abgewandt). Wenn Sie eine Webcam auf Ihrem Entwicklungscomputer verwenden, um die hintere Kamera auf dem emulierten Gerät zu simulieren, muss dieser Wert auf <code>webcam<i>n</i></code> festgelegt sein. Hierbei wählt <i>n</i> die Webcam aus. Wenn Sie nur eine Webcam besitzen, wählen Sie <code>webcam0</code> aus. Wenn dieser Wert auf <code>emulated</code> festgelegt ist, simuliert der Emulator die Kamera in der Software. Legen Sie diesen Wert auf <code>none</code> fest, um die hintere Kamera zu deaktivieren. Wenn Sie die hintere Kamera aktivieren, müssen Sie ebenfalls <code>hw.camera</code> aktivieren.  </td>
    <td> emulated, none, webcam0 </td>
</tr>
<tr>
    <td><code>hw.camera.front</code></td>
    <td><strong>Vordere Kamera:</strong> Konfiguriert die vordere Kamera (der Fokus ist dem Benutzer zugewandt). Wenn Sie eine Webcam auf Ihrem Entwicklungscomputer verwenden, um die vordere Kamera auf dem emulierten Gerät zu simulieren, muss dieser Wert auf <code>webcam<i>n</i></code> festgelegt sein. Hierbei wählt <i>n</i> die Webcam aus. Wenn Sie nur eine Webcam besitzen, wählen Sie <code>webcam0</code> aus. Wenn dieser Wert auf <code>emulated</code> festgelegt ist, simuliert der Emulator eine Kamera in der Software. Legen Sie diesen Wert auf <code>none</code> fest, um die vordere Kamera zu deaktivieren. Wenn Sie die vordere Kamera aktivieren, müssen Sie ebenfalls <code>hw.camera</code> aktivieren.  </td>
    <td> emulated, none, webcam0 </td>
</tr>
<tr>
    <td><code>hw.camera.maxHorizontalPixels</code></td>
    <td><strong>Maximale horizontale Pixel der Kamera:</strong> Konfiguriert die maximale horizontale Auflösung der Kamera des emulierten Geräts (in Pixeln).  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.camera.maxVerticalPixels</code></td>
    <td><strong>Maximale vertikale Pixel der Kamera:</strong> Konfiguriert die maximale vertikale Auflösung der Kamera des emulierten Geräts (in Pixeln).  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.cpu.arch</code></td>
    <td><strong>CPU-Architektur:</strong> Die CPU-Architektur, die vom virtuellen Gerät emuliert werden soll. Wenn Sie Intel HAXM für die Hardwarebeschleunigung verwenden, wählen Sie <code>x86</code> für eine 32-Bit-CPU aus. Wählen Sie <code>x86_64</code> für ein durch HAXM beschleunigtes 64-Bit-Gerät aus. (Achten Sie darauf, das entsprechende Intel x86-Systemimage im SDK-Manager zu installieren, z.B. <strong>Intel x86 Atom</strong> oder <strong>Intel x86 Atom_64</strong>.) Wählen Sie <code>arm</code> für eine 32-Bit-ARM-CPU oder <code>arm64</code> für eine 64-Bit-ARM-CPU aus, um eine ARM-CPU zu simulieren. Bedenken Sie, dass auf ARM basierende virtuelle Geräte langsamer ausgeführt werden als auf x86 basierende Geräte, da für ARM keine Hardwarebeschleunigung verfügbar ist.  </td>
    <td> x86, x86_64, arm, arm64 </td>
</tr>
<tr>
    <td><code>hw.cpu.model</code></td>
    <td><strong>CPU-Modell:</strong> Dieser Wert wird normalerweise nicht manuell festgelegt, sondern von <code>hw.cpu.arch</code> abgeleitet, wenn der Wert nicht explizit festgelegt wird. Für die experimentelle Verwendung kann der Wert jedoch auf eine für einen Emulator spezifische Zeichenfolge festgelegt werden.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.dPad</code></td>
    <td><strong>Tasten für das Steuerkreuz:</strong> Bestimmt, ob das emulierte Gerät Tasten für das Steuerkreuz (DPad) unterstützt. Ein Steuerkreuz besitzt normalerweise vier Tasten, um die Richtung zu steuern.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.gps</code></td>
    <td><strong>GPS-Unterstützung:</strong> Bestimmt, ob das emulierte Gerät einen GPS-Empfänger (Global Positioning System) besitzt.  </td>
    <td> yes, no </td>
<tr>
</tr>
<tr>
    <td><code>hw.gpu.enabled</code></td>
    <td><strong>GPU-Emulation:</strong> Bestimmt, ob das emulierte Gerät die GPU-Emulation unterstützt. Wenn die GPU-Emulation aktiviert ist, wird Open GL for Embedded Systems (Open GL ES) zum Rendern von 2D- und 3D-Grafiken auf dem Bildschirm verwendet. Die zugehörige Einstellung für den GPU-Emulationsmodus bestimmt, wie die GPU-Emulation implementiert wird.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.gpu.mode</code></td>
    <td><strong>GPU-Emulationsmodus:</strong> Bestimmt, wie die GPU-Emulation vom Emulator implementiert wird. Wenn Sie <code>auto</code> auswählen, wählt der Emulator die Hardware- und Softwarebeschleunigung basierend auf dem Setup Ihres Entwicklungscomputers aus. Wenn Sie <code>host</code> auswählen, verwendet der Emulator die GPU Ihres Entwicklungscomputers, um ein schnelleres Rendering der GPU-Emulation auszuführen. Wenn Ihre GPU nicht mit dem Emulator kompatibel ist und Sie Windows verwenden, können Sie <code>angle</code> statt <code>host</code> verwenden. Der Modus <code>angle</code> verwendet DirectX, um eine ähnliche Leistung wie <code>host</code> bereitzustellen. Wenn Sie <code>mesa</code> auswählen, verwendet der Emulator die Mesa 3D-Softwarebibliothek, um Grafiken zu rendern. Wählen Sie <code>mesa</code> aus, wenn beim Rendern über die GPU Ihres Entwicklungscomputers Probleme auftreten. Der Modus <code>swiftshader</code> kann verwendet werden, um Grafiken mit einer etwas geringeren Leistung als bei der Verwendung der GPU Ihres Computers in Software zu rendern. Bei der Option <code>off</code> (Deaktivieren der Hardwareemulation von Grafiken) handelt es sich um eine veraltete Option, durch die einige Elemente falsch gerendert werden können. Die Verwendung wird daher nicht empfohlen. </td>
    <td> auto, host, mesa, angle, swiftshader, off </td>
</tr>
<tr>
    <td><code>hw.gsmModem</code></td>
    <td><strong>Unterstützung von GSM-Modems:</strong> Bestimmt, ob das emulierte Gerät ein Modem enthält, das GSM (Global System for Mobile Communications) für Mobilfunknetze unterstützt.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.initialOrientation</code></td>
    <td><strong>Ursprüngliche Bildschirmausrichtung:</strong> Konfiguriert die ursprüngliche Ausrichtung des Bildschirms auf dem emulierten Gerät (Hoch- oder Querformat). Im Hochformat ist der Bildschirm höher als er breit ist. Im Querformat ist der Bildschirm breiter als er hoch ist. Wenn das emulierte Gerät ausgeführt wird, können Sie die Ausrichtung ändern, wenn Hoch- und Querformat im Geräteprofil unterstützt werden.  </td>
    <td> portrait, landscape </td>
</tr>
<tr>
    <td><code>hw.keyboard</code></td>
    <td><strong>Tastaturunterstützung:</strong> Bestimmt, ob das emulierte Gerät eine QWERTY-Tastatur unterstützt.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.keyboard.charmap</code></td>
    <td><strong>Name der Zeichentabelle für die Tastatur:</strong> Der Name der Hardwarezeichentabelle für dieses Gerät. Hinweis: Dieser sollte immer dem Standard (<code>qwerty2</code>) entsprechen, wenn Sie das Systemimage nicht entsprechend geändert haben. Dieser Name wird zur Startzeit an den Kernel gesendet. Das Verwenden eines falschen Namens führt dazu, dass das virtuelle Gerät nicht verwendbar ist.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.keyboard.lid</code></td>
    <td><strong>Unterstützung für das Ein-/Ausblenden der Tastatur:</strong> Wenn die Tastaturunterstützung aktiviert ist, bestimmt diese Einstellung, ob die QWERTY-Tastatur geschlossen/ausgeblendet oder geöffnet/angezeigt werden kann. Diese Einstellung wird ignoriert, wenn <code>hw.keyboard</code> auf <code>FALSE</code> festgelegt ist. Hinweis: Der Standardwert ist <code>FALSE</code>, wenn das emulierte Gerät auf die API-Ebene 12 oder höher ausgerichtet ist.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.lcd.backlight</code></td>
    <td><strong>LCD-Hintergrundbeleuchtung:</strong> Bestimmt, ob eine LCD-Hintergrundbeleuchtung vom emulierten Gerät simuliert wird.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.lcd.density</code></td>
    <td><strong>LCD-Dichte:</strong> Die Dichte der emulierten LCD-Anzeige, die in von der Dichte unabhängigen Pixeln oder <i>dp</i> (bei „dp“ handelt es sich um eine virtuelle Pixeleinheit) gemessen wird. Wenn die Einstellung auf 160 dp festgelegt wird, entspricht jedes dp einem physischen Pixel. Zur Laufzeit verwendet Android diesen Wert, um die entsprechenden Ressourcen bzw. Objekte auszuwählen und für das richtige Rendering der Anzeige zu skalieren.  </td>
    <td> 120, 160, 240, 213, 320 </td>
</tr>
<tr>
    <td><code>hw.lcd.depth</code></td>
    <td><strong>LCD-Farbtiefe:</strong> Die Farbbittiefe des emulierten Framepuffers, der die Bitmap für das Ausführen der LCD-Anzeige enthält. Dieser Wert kann 16 Bit (65.536 mögliche Farben) oder 32 Bit (16.777.216 Farben plus Transparenz) betragen. Die Einstellung für 32 Bit kann die Ausführung des Emulators etwas verlangsamen, dafür wird die Genauigkeit der Farben verbessert.  </td>
    <td> 16, 32 </td>
</tr>
<tr>
    <td><code>hw.lcd.height</code></td>
    <td><strong>LCD-Pixelhöhe:</strong> Die Anzahl von Pixeln, die die vertikale Dimension der emulierten LCD-Anzeige bilden.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.lcd.width</code></td>
    <td><strong>LCD-Pixelbreite:</strong> Die Anzahl von Pixeln, die die horizontale Dimension der emulierten LCD-Anzeige bilden.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.mainKeys</code></td>
    <td><strong>Hardwaretasten „Zurück“ bzw. „Startbildschirm“:</strong> Bestimmt, ob das emulierte Gerät die Hardwareschaltflächen „Zurück“ und „Startseite“ für die Navigation unterstützt. Sie können diesen Wert auf <code>yes</code> festlegen, wenn die Schaltflächen nur in der Software implementiert werden. Wenn <code>hw.mainKeys</code> auf <code>yes</code> festgelegt wird, zeigt der Emulator keine Schaltflächen für die Navigation auf dem Bildschirm an, Sie können jedoch die Seitenleiste des Emulators verwenden, um diese Schaltflächen zu „drücken“.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.ramSize</code></td>
    <td><strong>RAM-Größe des Geräts:</strong> Die Größe des physischen RAM auf dem emulierten Gerät in Megabyte. Der Standardwert wird aus der Bildschirmgröße oder der Version der Skin berechnet. Das Erhöhen der Größe kann dazu führen, dass die Vorgänge des Emulators schneller ausgeführt werden. Dadurch werden jedoch mehr Ressourcen vom Entwicklungscomputer beansprucht.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.screen</code></td>
    <td><strong>Art des Touchscreens:</strong> Definiert die Art des Bildschirms auf dem emulierten Gerät. Ein Bildschirm mit <code>Multitoucheingabe</code> (multi-touch) kann zwei oder mehr Finger auf der Touchoberfläche erkennen. Ein Bildschirm mit <code>Toucheingabe</code> (touch) kann nur die Touchereignisse von einem Finger erkennen. Ein Bildschirm <code>ohne Toucheingabe</code> (no-touch) erkennt keine Touchereignisse.  </td>
    <td> touch, multi-touch, no-touch </td>
</tr>
<tr>
    <td><code>hw.sdCard</code></td>
    <td><strong>Unterstützung für SD-Karten:</strong> Bestimmt, ob das emulierte Gerät das Einfügen und Entfernen von virtuellen SD-Karten (Secure Digital) unterstützt. Der Emulator verwendet bereitstellbare Datenträgerimages, die auf Ihrem Entwicklungscomputer gespeichert sind, um die Partitionen der tatsächlichen SD-Kartengeräte zu simulieren. Weitere Informationen finden Sie unter <code>hw.sdCard.path</code>.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>sdcard.size</code></td>
    <td><strong>Größe der SD-Karte:</strong> Gibt die Größe der virtuellen SD-Kartendatei an dem Speicherort an, der von <code>hw.sdCard.path</code> angegeben wird und auf dem Gerät verfügbar ist (in Byte). Wenn die Größe einer einfachen ganzen Zahl entspricht, wird diese in Byte angegeben. Sie können die Größe ebenfalls in Kilobyte, Megabyte oder Gigabyte angeben, indem Sie der Größenangabe K, M oder G hinzufügen. Die minimale Größe beträgt 9 MB, die maximale Größe 1023 GB.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.sdCard.path</code></td>
    <td><strong>Imagepfad der SD-Karte:</strong> Gibt den Dateinamen und den Pfad der Imagedatei für die Partition einer SD-Karte auf Ihrem Entwicklungscomputer an. Dieser Pfad kann unter Windows beispielsweise auf <strong>C:\sd\sdcard.img</strong> festgelegt werden.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>hw.sensors.magnetic_field</code></td>
    <td><strong>Sensor für Magnetfelder:</strong> Bestimmt, ob das emulierte Gerät einen Sensor für Magnetfelder unterstützt. Der Sensor für Magnetfelder (auch als Magnetometer bekannt) meldet das geomagnetische Feld der Umgebung, die von drei Sensorachsen gemessen werden. Aktivieren Sie diese Einstellung für Apps, die Zugriff auf das Lesen von Kompassen benötigen. Eine Navigations-App kann diesen Sensor beispielsweise verwenden, um die Richtung des Benutzers zu erkennen.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.sensors.orientation</code></td>
    <td><strong>Ausrichtungssensor:</strong> Bestimmt, ob das emulierte Gerät Werte für den Orientierungssensor bereitstellt. Der Ausrichtungssensor misst den Grad der Drehung des Geräts um alle drei physischen Achsen (x, y, z). Beachten Sie, dass der Ausrichtungssensor seit Android 2.2 (API-Ebene 8) veraltet ist.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.sensors.proximity</code></td>
    <td><strong>Näherungssensor:</strong> Bestimmt, ob das emulierte Gerät einen Näherungssensor unterstützt. Dieser Sensor misst die Näherung eines Objekts relativ zum Bildschirm eines Geräts. Dieser Sensor wird üblicherweise verwendet, um zu bestimmen, ob ein Mobilgerät auf der Höhe des Ohrs einer Person gehalten wird.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.sensors.temperature</code></td>
    <td><strong>Temperatursensor:</strong> Bestimmt, ob das emulierte Gerät einen Temperatursensor unterstützt. Der Sensor misst die Temperatur des Geräts in Grad Celsius (°C).  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.touchScreen</code></td>
    <td><strong>Touchscreenunterstützung:</strong> Bestimmt, ob das emulierte Gerät einen Touchscreen unterstützt. Der Touchscreen wird für die direkte Bearbeitung des Objekts auf dem Bildschirm verwendet.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.trackBall</code></td>
    <td><strong>Trackballunterstützung:</strong> Bestimmt, ob das emulierte Gerät einen Trackball unterstützt.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code>hw.useext4</code></td>
    <td><strong>Unterstützung des EXT4-Dateisystems:</strong> Bestimmt, ob das emulierte Gerät das Linux-Dateisystem „EXT4“ für Partitionen verwendet. Da der Typ des Dateisystems mittlerweile automatisch erkannt wird, ist diese Option veraltet und wird ignoriert.  </td>
    <td> Nein </td>
</tr>
<tr>
    <td><code>kernel.newDeviceNaming</code></td>
    <td><strong>Neue Gerätebenennung für den Kernel:</strong> Gibt an, ob der Kernel ein neues Benennungsschema für Geräte erfordert. Diese Eigenschaft wird üblicherweise mit Kernels von Linux 3.10 und höher verwendet. Wenn <code>autodetect</code> festgelegt ist, erkennt der Emulator automatisch, ob der Kernel ein neues Benennungsschema für Geräte erfordert.  </td>
    <td> autodetect, yes, no </td>
</tr>
<tr>
    <td><code>kernel.parameters</code></td>
    <td><strong>Parameter für den Kernel:</strong> Gibt für Linux-Kernels die Zeichenfolge der Parameter für den Systemstart an. Diese Einstellung bleibt standardmäßig leer.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>kernel.path</code></td>
    <td><strong>Kernelpfad:</strong> Gibt den Pfad zum Linux-Kernel an. Wenn dieser Pfad nicht angegeben wird, durchsucht der Emulator das Systemverzeichnis des Emulators nach <code>kernel-ranchu</code>.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code>kernel.supportsYaffs2</code></td>
    <td><strong>Unterstützung der YAFFS2-Partition:</strong> Bestimmt, ob der Kernel YAFFS2-Partitionen (Yet Another Flash File System 2) unterstützt. Dies gilt in der Regel nur für Kernels vor Linux 3.10. Wenn <code>autodetect</code> festgelegt ist, erkennt der Emulator automatisch, ob der Kernel YAFFS2-Dateisysteme einlegen kann.  </td>
    <td> autodetect, yes, no </td>
</tr>
<tr>
    <td><code>skin.name</code></td>
    <td><strong>Name der Skin:</strong> Der Name für die Skin eines Android-Emulators. Bei einer Skin handelt es sich um eine Sammlung von Dateien, die die visuellen Elemente und Steuerelemente der Anzeige eines Emulators definiert. Sie beschreibt, wie das Fenster des virtuellen Android-Geräts auf Ihrem Entwicklungscomputer angezeigt wird. Eine Skin beschreibt die Bildschirmgröße, die Schaltflächen und das gesamte Design, hat jedoch keine Auswirkungen auf die Ausführung Ihrer App. </td>
    <td> </td>
</tr>
<tr>
    <td><code>skin.path</code></td>
    <td><strong>Pfad zur Skin:</strong> Der Pfad zum Verzeichnis, der die Skindateien des Emulators enthält, die in <code>skin.name</code> angegeben werden. Dieses Verzeichnis enthält die Layoutdateien <code>hardware.ini</code> sowie Bilddateien für die angezeigten Elemente der Skin. </td>
    <td> </td>
</tr>
<tr>
    <td><code>skin.dynamic</code></td>
    <td><strong>Skindynamik:</strong> Gibt an, ob die Skin dynamisch ist oder nicht. Bei der Skin des Emulators handelt es sich um eine dynamische Skin, wenn der Emulator eine Skin einer bestimmten Größe erstellen soll, die auf einer angegebenen Breite und Höhe basiert. </td>
    <td> Nein </td>
</tr>
</table>
