|Eigenschaft|Beschreibung|Optionen|
|--- |--- |--- |
|`abi.type`|**ABI-Typ** &ndash; gibt den Typ ABI (Application binary Interface) des Geräts "emuliert". Die **X86** Option wird häufig als "X86" oder "IA-32." bezeichnet Instruktionssatz Die **x86_64** Option ist für die 64-Bit-X86-Befehlssatz. Die **Armeabi v7a** Option wird der ARM-Instruktionssatz mit v7-a-ARM-Erweiterungen. Die **arm64 v8a** Option ist für den ARM-Anweisungssatz, der AArch64 unterstützt.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Zwischenspeichern von Partition** &ndash; bestimmt, ob das Gerät "emuliert" eine **/zwischenspeichern** Partition auf dem Gerät. Die **/zwischenspeichern** Partition (der anfänglich leer ist) ist der Speicherort, auf dem Android, häufig verwendete Daten und app-Komponenten speichert. Wenn auf festgelegt **keine**, der Emulator nicht verwenden eine **/zwischenspeichern** Partition und die andere `disk.cache` Einstellungen werden ignoriert.|yes, no|
|`disk.cachePartition.path`|**Partition Cachepfad** &ndash; gibt eine Partition Image-Cachedatei auf dem Entwicklungscomputer. Der Emulator verwendet diese Datei für die **/zwischenspeichern** Partition. Geben Sie einen absoluten Pfad oder ein Pfad relativ zum Datenverzeichnis der Emulator. Wenn nicht festgelegt ist, der Emulator eine leere temporäre Datei mit dem Namen erstellt **cache.img** auf Ihrem Computer. Wenn die Datei noch nicht vorhanden ist, wird sie als leere Datei erstellt. Diese Option wird ignoriert, wenn `disk.cachePartition` festgelegt ist, um **keine**.||
|`disk.cachePartition.size`|**Partition Cachegröße** &ndash; die Größe der Partition Cachedatei (in MB). Normalerweise müssen Sie diese Option nur dann festlegen, wenn die App sehr große Dateien herunterlädt, die die Standardgröße des Caches von 66 Megabyte übersteigen. Diese Option wird ignoriert, wenn `disk.cachePartition` festgelegt ist, um **keine**.||
|`disk.dataPartition.initPath`|**In der Datenpartition Anfangspfad** &ndash; gibt die anfänglichen Inhalte des der Datenpartition. Nach dem Zurücksetzen von Benutzerdaten, kopiert der Emulator den Inhalt der angegebenen Datei auf Benutzerdaten (standardmäßig **Userdata qemu.img**) anstatt **userdata.img** als die erste Version.||
|`disk.dataPartition.path`|**Pfad in der Datenpartition** &ndash; Benutzerdatendatei Partition angibt. Geben Sie einen Dateinamen und einen Pfad auf Ihrem Entwicklungscomputer ein, um eine permanente Datei für Benutzerdaten zu konfigurieren. Wenn die Datei nicht vorhanden ist, erstellt der Emulator ein Bild aus der Standarddatei **userdata.img**, speichert sie in dem durch angegebenen Dateinamen `disk.dataPartition.path`, und Benutzerdaten an ihn weiterhin besteht, wenn der Emulator wird heruntergefahren. Wenn Sie einen Pfad angeben, lautet die standardmäßige Datei **Userdata qemu.img**. Der spezielle Wert  **<temp>**  bewirkt, dass den Emulator erstellen und Verwenden einer temporären Datei. Wenn `disk.dataPartition.initPath` festgelegt ist, dessen Inhalt in die Datei disk.dataPartition.path beim Systemstart kopiert werden. Beachten Sie, dass diese Option nicht leer bleiben darf.||
|`disk.dataPartition.size`|**Daten Partitionsgröße** &ndash; gibt die Größe der Partition der Benutzerdaten in MB an.||
|`disk.ramdisk.path`|**RAMDisk-Pfad** &ndash; Pfad für das Startabbild für die Partition (Ramdisk). Das RAMDISK-Image ist eine Teilmenge des Systemimages, das vom Kernel geladen wird, bevor das Systemimage eingebunden wird. Das RAMDISK-Image enthält üblicherweise die Binärdateien für die Startzeit und Initialisierungsskripts. Wenn diese Option nicht angegeben ist, wird standardmäßig **ramdisk.img** im Emulator-Systemverzeichnis.||
|`disk.snapStorage.path`|**Momentaufnahme-Speicherpfad** &ndash; Pfad in der Momentaufnahme-Speicherdatei, in dem alle Momentaufnahmen gespeichert werden. Alle Momentaufnahmen, die während der Ausführung aufgenommen werden, werden in dieser Datei gespeichert. Nur Momentaufnahmen, die in dieser Datei gespeichert werden, können während der Ausführung des Emulators wiederhergestellt werden. Wenn diese Option nicht angegeben wird, ist die Standardeinstellung snapshots.img im Emulator Data-Verzeichnis.||
|`disk.systemPartition.initPath`|**Pfad zur System Partition Init** &ndash; Pfad auf die schreibgeschützte Kopie der Betriebssystemabbilddatei an; insbesondere Partition, die den Systembibliotheken und entsprechenden API-Ebene und eine Variante Daten enthält. Wenn dieser Pfad nicht angegeben wird, ist die Standardeinstellung system.img im Emulator-Systemverzeichnis.||
|`disk.systemPartition.path`|**Partition Systempfad** &ndash; Pfad zu der Schreib-Lese-Abbild in der Partition. Wenn dieser Pfad nicht festgelegt ist, eine temporäre Datei wird erstellt und initialisiert werden aus dem Inhalt der Datei gemäß `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**System-Partitionsgröße** &ndash; die ideale Größe die Systempartition (in MB). Diese Größenangabe wird ignoriert, wenn die tatsächliche Größe des Images der Systempartition diese Einstellung übersteigt. Andernfalls wird die maximale Größe angegeben, die die Systempartitionsdatei erreichen kann.||
|`hw.accelerometer`|**Beschleunigungsmesser** &ndash; bestimmt, ob das Gerät "emuliert" einen Sensor Beschleunigungsmesser enthält. Der Beschleunigungsmesser unterstützt das Gerät bei der Orientierung (z.B. für die automatische Drehung). Der Beschleunigungsmesser meldet die Beschleunigung des Geräts an drei Sensorachsen.|yes, no|
|`hw.audioInput`|**Unterstützung der Audioaufnahme** &ndash; bestimmt, ob das Gerät "emuliert" Audio aufzeichnen kann.|yes, no|
|`hw.audioOutput`|**Audiowiedergabe Unterstützung** &ndash; bestimmt, ob das Gerät "emuliert" audio wiedergegeben werden kann.|yes, no|
|`hw.battery`|**Akku Unterstützung** &ndash; bestimmt, ob das Gerät "emuliert" im Akkubetrieb ausgeführt werden kann.|yes, no|
|`hw.camera`|**Unterstützung der Kamera** &ndash; bestimmt, ob das Gerät "emuliert" eine Kamera verfügt.|yes, no|
|`hw.camera.back`|**Back-verbundene Kamera** &ndash; die Kamera Back verbundene (Weg von der Benutzer den Fokus Flächen) konfiguriert. Wenn Sie eine Webcam auf dem Entwicklungscomputer simuliert die Back-verbundene Kamera des Geräts "emuliert" verwenden werden, muss dieser Wert festgelegt werden, um Webcam*n*, wobei _n_ wählt die Webcam (Wenn Sie nur eine Webcam haben Wählen Sie **webcam0**). Wenn auf festgelegt emuliert, simuliert der Emulator die Kamera in der Software. Legen Sie diesen Wert zum Deaktivieren der Kamera Back verbundene auf none. Wenn Sie die Kamera verbundene wieder zu aktivieren, müssen Sie auch aktivieren `hw.camera`.|emulated, none, webcam0|
|`hw.camera.front`|**Nach außen gerichtete Kamera** &ndash; konfiguriert die Kamera nach außen gerichtete (die Linse Gesichter in Richtung des Benutzers). Wenn Sie eine Webcam auf Ihrem Entwicklungscomputer verwenden die Kamera nach außen gerichtete emulierten Gerät simuliert, muss dieser Wert festgelegt werden, um Webcam*n*, wobei _n_ wählt die Webcam (Wenn Sie nur eine Webcam haben Wählen Sie **webcam0**). Wenn auf festgelegt emuliert, simuliert der Emulator eine Kamera in der Software. Legen Sie diesen Wert zum Deaktivieren der Kamera nach außen gerichtete auf none. Wenn Sie die Kamera nach außen gerichtete aktivieren, achten Sie darauf auch aktiviert werden `hw.camera`.|emulated, none, webcam0|
|`hw.camera.maxHorizontalPixels`|**Maximale horizontale Kamera Pixel** &ndash; konfiguriert die maximale horizontale Auflösung des Geräts "emuliert" Kamera (in Pixel).||
|`hw.camera.maxVerticalPixels`|**Maximale vertikale Kamera Pixel** &ndash; konfiguriert die maximale vertikale Auflösung des Geräts "emuliert" Kamera (in Pixel).||
|`hw.cpu.arch`|**CPU-Architektur** &ndash; im CPU-Architektur, indem Sie das virtuelle Gerät emuliert werden. Wählen Sie bei Verwendung von Intel HAXM für die Hardwarebeschleunigung **X86** für einen 32-Bit-Prozessor. Wählen Sie **x86_64** für ein Gerät für die 64-Bit-HAXM beschleunigt. (Achten Sie darauf, dass Sie das entsprechende Intel X86 Systemabbild in den SDK-Manager installieren: z. B. Intel X86 Atom oder Intel X86 Atom_64.) Wählen Sie ein ARM-CPU zu simulieren, **Arm** für 32-Bit- oder select **arm64** für einen 64-Bit-ARM-Prozessor. Bedenken Sie, dass auf ARM basierende virtuelle Geräte langsamer ausgeführt werden als auf x86 basierende Geräte, da für ARM keine Hardwarebeschleunigung verfügbar ist.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**CPU-Modell** &ndash; dieser Wert wird normalerweise bleiben unset (wird auf einen Wert an, die abgeleitet ist festgelegt `hw.cpu.arch` , wenn sie nicht explizit festgelegt ist). Für die experimentelle Verwendung kann der Wert jedoch auf eine für einen Emulator spezifische Zeichenfolge festgelegt werden.||
|`hw.dPad`|**"Dpad" Schlüssel** &ndash; bestimmt, ob das Gerät "emuliert" Schlüssel Steuerkreuz ("Dpad") unterstützt. Ein Steuerkreuz besitzt normalerweise vier Tasten, um die Richtung zu steuern.|yes, no|
|`hw.gps`|**GPS-Unterstützung** &ndash; bestimmt, ob das Gerät "emuliert" GPS (GPS) Empfänger hat.|yes, no|
|`hw.gpu.enabled`|**GPU-Emulation** &ndash; bestimmt, ob das Gerät "emuliert" GPU-Emulation unterstützt. Wenn die GPU-Emulation aktiviert ist, wird Open GL for Embedded Systems (Open GL ES) zum Rendern von 2D- und 3D-Grafiken auf dem Bildschirm verwendet. Die zugehörige Einstellung für den GPU-Emulationsmodus bestimmt, wie die GPU-Emulation implementiert wird.|yes, no|
|`hw.gpu.mode`|**GPU-Emulationsmodus** &ndash; bestimmt, wie die GPU-Emulation vom Emulator implementiert wird. Bei Auswahl der automatischen Emulator Hardware und Software-basierend auf Ihrer Entwicklung Computer Einrichtung Beschleunigung wählen Sie aus. Wenn Sie den Host auswählen, verwendet der Emulator Grafikprozessor dem Entwicklungscomputer für GPU-Emulation damit schneller Rendering ausführen aus. Wenn Ihr GPU nicht kompatibel mit dem Emulator ist aus, und Sie befinden sich auf Windows, können Sie Spitzen anstelle von Host versuchen. Der Winkel-Modus verwendet DirectX Host ähnelt Leistung bringt. Bei Auswahl des Mesa verwendet der Emulator 3D Softwarebibliothek Mesa zum Rendern von Grafiken. Wählen Sie Mesa, wenn Sie Probleme, die über dem Entwicklungscomputer Grafikprozessor Rendern verwenden. Der Modus Swiftshader kann zum Rendern von Grafiken in Software mit etwas weniger Leistung als die Verwendung des Computers GPUS verwendet werden. Die off-Option (Graphics-Hardware-Emulation deaktivieren) ist eine veraltete Option, die dazu unsachgemäßes Rendern für einige Elemente und wird daher nicht empfohlen.|auto, host, mesa, angle, swiftshader, off|
|`hw.gsmModem`|**Unterstützung von GSM Modems** &ndash; bestimmt, ob das Gerät "emuliert" Modem enthält, die das GSM (Global System for Mobile Communications) Telefonie Radio System unterstützt.|yes, no|
|`hw.initialOrientation`|**Anfängliche bildschirmausrichtung** &ndash; die ursprüngliche Ausrichtung des Bildschirms auf das emulierte Gerät (hoch- oder Querformat-Modus) konfiguriert. Im Hochformat ist der Bildschirm höher als er breit ist. Im Querformat ist der Bildschirm breiter als er hoch ist. Wenn das emulierte Gerät ausgeführt wird, können Sie die Ausrichtung ändern, wenn Hoch- und Querformat im Geräteprofil unterstützt werden.|portrait, landscape|
|`hw.keyboard`|**Tastatur Unterstützung** &ndash; bestimmt, ob das Gerät "emuliert" QWERTY Tastatur unterstützt.|yes, no|
|`hw.keyboard.charmap`|**Tastatur Charmap Namen** &ndash; den Namen des der Hardware Charmap für dieses Gerät. Hinweis: Dies sollte immer die Standardeinstellung sein **qwerty2** , wenn Sie das Systemabbild entsprechend geändert haben. Dieser Name wird zur Startzeit an den Kernel gesendet. Das Verwenden eines falschen Namens führt dazu, dass das virtuelle Gerät nicht verwendbar ist.||
|`hw.keyboard.lid`|**Tastatur tragbaren Unterstützung** &ndash; Wenn Tastatur-Unterstützung aktiviert ist, diese Einstellung bestimmt, ob der QWERTY Tastatur geschlossen/ausgeblendet kann werden oder geöffnet/sichtbar. Diese Einstellung wird ignoriert, wenn hw.keyboard auf "false" festgelegt ist. Hinweis: der Standardwert ist "false", wenn das Gerät "emuliert" API-Ebene 12 oder höher abzielt.|yes, no|
|`hw.lcd.backlight`|**LCD Beleuchtung** &ndash; bestimmt, ob ein LCD Beleuchtung vom emulierten Gerät simuliert wird.|yes, no|
|`hw.lcd.density`|**LCD Dichte** &ndash; die Dichte des emulierten LCD-Anzeige, gemessen in Pixel Dichte unabhängig oder dp (dp ist eine Einheit virtuellen Pixel). Wenn die Einstellung auf 160 dp festgelegt wird, entspricht jedes dp einem physischen Pixel. Zur Laufzeit verwendet Android diesen Wert, um die entsprechenden Ressourcen bzw. Objekte auszuwählen und für das richtige Rendering der Anzeige zu skalieren.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**LCD Farbtiefe** &ndash; -Farbtiefe des emulierten framepuffers, die die Bitmap für die LCD-Anzeige erhöhen auf diese Weise enthält. Dieser Wert kann 16 Bit (65.536 mögliche Farben) oder 32 Bit (16.777.216 Farben plus Transparenz) betragen. Die Einstellung für 32 Bit kann die Ausführung des Emulators etwas verlangsamen, dafür wird die Genauigkeit der Farben verbessert.|16, 32|
|`hw.lcd.height`|**LCD Pixelhöhe** &ndash; die Anzahl der Pixel, die die vertikale Dimension der emulierten LCD Anzeige bilden.||
|`hw.lcd.width`|**Pixelbreite LCD** &ndash; die Anzahl der Pixel, die die horizontale Abmessung "emuliert" LCD-Anzeige bilden.||
|`hw.mainKeys`|**Hardware Back und private Schlüssel** &ndash; bestimmt, ob das emulierte Gerät wieder Hardware unterstützt und Home Navigationsschaltflächen. Sie können diesen Wert festlegen, um **Ja** , wenn die Schaltflächen nur in der Software implementiert werden. Wenn `hw.mainKeys` festgelegt ist, um **Ja**, der Emulator nicht Navigationsschaltflächen auf dem Bildschirm angezeigt wird, jedoch können Sie den Emulator Seitenwand "Diese Schaltflächen klicken auf".|yes, no|
|`hw.ramSize`|**Gerät RAM-Größe** &ndash; die Größe des physischen Arbeitsspeichers auf dem Gerät "emuliert" in Megabyte. Der Standardwert wird aus der Bildschirmgröße oder der Version der Skin berechnet. Das Erhöhen der Größe kann dazu führen, dass die Vorgänge des Emulators schneller ausgeführt werden. Dadurch werden jedoch mehr Ressourcen vom Entwicklungscomputer beansprucht.||
|`hw.screen`|**Touch-Bildschirmtyps** &ndash; definiert den Typ des Bildschirms auf dem Gerät emuliert. Ein Multi-Touch-Bildschirm kann mindestens zwei Fingern auf die Touch-Schnittstelle nachverfolgen. Ein Touchscreen kann nur einem Finger Berührungsereignisse erkennen. Kein Touchscreen erkennt keine Berührungsereignisse.|touch, multi-touch, no-touch|
|`hw.sdCard`|**Unterstützung von SDCard** &ndash; bestimmt, ob das Gerät "emuliert" Einfügen und Entfernen von virtuellen (Secure Digital) SD-Karten unterstützt. Der Emulator verwendet bereitstellbar Datenträgerabbilder auf Ihrem Computer gespeichert, um die Partitionen der tatsächlichen SD-Kartengeräte simulieren (Siehe hw.sdCard.path).|yes, no|
|`sdcard.size`|**SDCard Größe** &ndash; gibt die Größe des virtuellen SD-Kartendatei am Speicherort vom angegebenen `hw.sdCard.path`. auf dem Gerät (in Byte) verfügbar. Wenn die Größe einer einfachen ganzen Zahl entspricht, wird diese in Byte angegeben. Sie können die Größe ebenfalls in Kilobyte, Megabyte oder Gigabyte angeben, indem Sie der Größenangabe K, M oder G hinzufügen. Die minimale Größe beträgt 9 MB, die maximale Größe 1023 GB.||
|`hw.sdCard.path`|**Bildpfad SDCard** &ndash; gibt den Dateinamen und Pfad in eine Bilddatei auf dem Entwicklungscomputer SD-Karte Partition. Beispielsweise konnte diesen Pfad festgelegt werden, um **C:\sd\sdcard.img** unter Windows.||
|`hw.sensors.magnetic_field`|**Elektromagnetischen Feld Sensor** &ndash; bestimmt, ob das Gerät "emuliert" elektromagnetischen Feld Sensor unterstützt. Der Sensor für Magnetfelder (auch als Magnetometer bekannt) meldet das geomagnetische Feld der Umgebung, die von drei Sensorachsen gemessen werden. Aktivieren Sie diese Einstellung für Apps, die Zugriff auf das Lesen von Kompassen benötigen. Eine Navigations-App kann diesen Sensor beispielsweise verwenden, um die Richtung des Benutzers zu erkennen.|yes, no|
|`hw.sensors.orientation`|**Ausrichtung Sensor** &ndash; bestimmt, ob das emulierte Gerät Ausrichtung stellt Sensorwerte bereit. Der Ausrichtungssensor misst den Grad der Drehung des Geräts um alle drei physischen Achsen (x, y, z). Beachten Sie, dass der Ausrichtungssensor seit Android 2.2 (API-Ebene 8) veraltet ist.|yes, no|
|`hw.sensors.proximity`|**NEAR-Temperatursensor** &ndash; bestimmt, ob das Gerät "emuliert" NEAR Sensor unterstützt. Dieser Sensor misst die Näherung eines Objekts relativ zum Bildschirm eines Geräts. Dieser Sensor wird üblicherweise verwendet, um zu bestimmen, ob ein Mobilgerät auf der Höhe des Ohrs einer Person gehalten wird.|yes, no|
|`hw.sensors.temperature`|**Temperatursensor** &ndash; bestimmt, ob das Gerät "emuliert" ein Temperatursensors überwacht unterstützt. Dieser Sensor misst die Temperatur in Grad Celsius-Geräts (&deg;C).|yes, no|
|`hw.touchScreen`|**Unterstützung für Touchscreen** &ndash; bestimmt, ob das Gerät "emuliert" kein Touchscreen unterstützt. Der Touchscreen wird für die direkte Bearbeitung des Objekts auf dem Bildschirm verwendet.|yes, no|
|`hw.trackBall`|**Unterstützung von Trackball** &ndash; bestimmt, ob das Gerät "emuliert" eine Trackball unterstützt.|yes, no|
|`hw.useext4`|**EXT4 Datei systemunterstützung** &ndash; bestimmt, ob das Gerät "emuliert" Linux EXT4 Dateisystem für Partitionen verwendet. Da der Typ des Dateisystems mittlerweile automatisch erkannt wird, ist diese Option veraltet und wird ignoriert.|Nein|
|`kernel.newDeviceNaming`|**Kernel neue Gerät Benennung** &ndash; verwendet, um anzugeben, ob der Kernel ein neues Gerät Benennungsschema erforderlich ist. Diese Eigenschaft wird üblicherweise mit Kernels von Linux 3.10 und höher verwendet. Wenn auf festgelegt **AutoErmittlung**, der Emulator erkennt automatisch, ob der Kernel ein neues Gerät Benennungsschema erforderlich ist.|autodetect, yes, no|
|`kernel.parameters`|**Kernel-Parameter** &ndash; gibt die Zeichenfolge der Linux-Kernel-Boot-Parameter. Diese Einstellung bleibt standardmäßig leer.||
|`kernel.path`|**Kernel-Pfad** &ndash; gibt den Pfad zu den Linux-Kernel. Wenn dieser Pfad nicht angegeben ist, sucht der Emulator im Systemverzeichnis für Kernel-Ranchu Emulator.||
|`kernel.supportsYaffs2`|**YAFFS2 partitionsunterstützung** &ndash; bestimmt, ob der Kernel YAFFS2 unterstützt (noch eine andere Flash Datei System 2) Partitionen. Dies gilt in der Regel nur für Kernels vor Linux 3.10. Wenn auf festgelegt **AutoErmittlung** Emulator erkennt automatisch, ob der Kernel YAFFS2 Dateisysteme einbinden kann.|autodetect, yes, no|
|`skin.name`|**Namen für das Design** &ndash; der Name für ein Android-Emulator-Design. Bei einer Skin handelt es sich um eine Sammlung von Dateien, die die visuellen Elemente und Steuerelemente der Anzeige eines Emulators definiert. Sie beschreibt, wie das Fenster des virtuellen Android-Geräts auf Ihrem Entwicklungscomputer angezeigt wird. Eine Skin beschreibt die Bildschirmgröße, die Schaltflächen und das gesamte Design, hat jedoch keine Auswirkungen auf die Ausführung Ihrer App.||
|`skin.path`|**Design Pfad** &ndash; Pfad zum Verzeichnis mit den Emulator Skin-Dateien an angegebenen in skin.name dieses Verzeichnis enthält hardware.ini Layout-Dateien sowie -Abbilddateien für die Anzeigeelemente des Designs.||
|`skin.dynamic`|**Design Dynamic** &ndash; , ob das Design dynamisch ist. Bei der Skin des Emulators handelt es sich um eine dynamische Skin, wenn der Emulator eine Skin einer bestimmten Größe erstellen soll, die auf einer angegebenen Breite und Höhe basiert.|Nein|

